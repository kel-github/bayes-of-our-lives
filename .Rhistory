inits = function() {
inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,1.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags, inits=inits, n.chains=3)
str(data_jags) # make sure that all variables have the same number of observations (712).
data_jags = as.list(as.data.frame(X))
data_jags
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
str(data_jags)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
inits = function() {
inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,1.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags, inits=inits, n.chains=3)
inits = function() {
inits = list("b0"=rnorm(1), "b"=rnorm(4))
}
mod = jags.model(textConnection(mod_string), data=data_jags, inits=inits, n.chains=3)
inits = function() {
inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,1.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags, inits=inits, n.chains=3)
data_jag
str(data_jags)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
inits = function() {
inits = list("b0"=rnorm(1,1.0,100.0), "b"=rnorm(4,1.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags, inits=inits, n.chains=3)
update(mod, 1000) # burn-in
params = c("b0", "b")
inits = function() {
inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags, inits=inits, n.chains=3)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
inits = function() {
inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags, inits=inits, n.chains=3)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
# inits = function() {
#   inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
# }
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
update(mod, 1000) # burn-in
View(data_jags)
data_jags[["y"]]
View(data_jags$y)
mod1_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbern(p[i])
logit(p[i]) = int + b[1]*gravity[i] + b[2]*ph[i] + b[3]*osmo[i] + b[4]*cond[i] + b[5]*urea[i] + b[6]*calc[i]
}
int ~ dnorm(0.0, 1.0/25.0)
for (j in 1:6) {
b[j] ~ ddexp(0.0, sqrt(2.0)) # has variance 1.0
}
} "
set.seed(92)
head(X)
data_jags = list(y=dat$r, gravity=X[,"gravity"], ph=X[,"ph"], osmo=X[,"osmo"], cond=X[,"cond"], urea=X[,"urea"], calc=X[,"calc"])
params = c("int", "b")
mod1 = jags.model(textConnection(mod1_string), data=data_jags, n.chains=3)
update(mod1, 1e3)
mod1_sim = coda.samples(model=mod1,
variable.names=params,
n.iter=5e3)
data("urine")
dat = na.omit(urine)
mod1_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbern(p[i])
logit(p[i]) = int + b[1]*gravity[i] + b[2]*ph[i] + b[3]*osmo[i] + b[4]*cond[i] + b[5]*urea[i] + b[6]*calc[i]
}
int ~ dnorm(0.0, 1.0/25.0)
for (j in 1:6) {
b[j] ~ ddexp(0.0, sqrt(2.0)) # has variance 1.0
}
} "
set.seed(92)
head(X)
data_jags = list(y=dat$r, gravity=X[,"gravity"], ph=X[,"ph"], osmo=X[,"osmo"], cond=X[,"cond"], urea=X[,"urea"], calc=X[,"calc"])
params = c("int", "b")
mod1 = jags.model(textConnection(mod1_string), data=data_jags, n.chains=3)
update(mod1, 1e3)
mod1_sim = coda.samples(model=mod1,
variable.names=params,
n.iter=5e3)
data("urine")
dat = na.omit(urine)
X = scale(dat[,-1], center=TRUE, scale=TRUE)
mod1_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbern(p[i])
logit(p[i]) = int + b[1]*gravity[i] + b[2]*ph[i] + b[3]*osmo[i] + b[4]*cond[i] + b[5]*urea[i] + b[6]*calc[i]
}
int ~ dnorm(0.0, 1.0/25.0)
for (j in 1:6) {
b[j] ~ ddexp(0.0, sqrt(2.0)) # has variance 1.0
}
} "
set.seed(92)
head(X)
data_jags = list(y=dat$r, gravity=X[,"gravity"], ph=X[,"ph"], osmo=X[,"osmo"], cond=X[,"cond"], urea=X[,"urea"], calc=X[,"calc"])
params = c("int", "b")
mod1 = jags.model(textConnection(mod1_string), data=data_jags, n.chains=3)
update(mod1, 1e3)
mod1_sim = coda.samples(model=mod1,
variable.names=params,
n.iter=5e3)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
head(X)
library("MASS")
library("rjags")
data("OME")
?OME # background on the data
head(OME)
any(is.na(OME)) # check for missing values
dat = subset(OME, OME != "N/A") # manually remove OME missing values identified with "N/A"
dat$OME = factor(dat$OME)
str(dat)
plot(as.factor(dat$Age), dat$Correct / dat$Trials )
plot(as.factor(dat$OME), dat$Correct / dat$Trials )
plot(as.factor(dat$Loud), dat$Correct / dat$Trials )
plot(dat$Noise, dat$Correct / dat$Trials )
pairs(dat)
mod_glm = glm(Correct/Trials ~ Age + OME + Loud + Noise, data=dat, weights=Trials, family="binomial")
summary(mod_glm)
plot(residuals(mod_glm, type="deviance"))
plot(fitted(mod_glm), dat$Correct/dat$Trials)
# Export configuration of covariates
X = model.matrix(mod_glm)[,-1] # -1 removes the column of 1s for the intercept
head(X)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
X$Age = scale(X$Age)
head(X)
X[,"Age"]
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
X[,"Loud"] = scale(X[,"Loud"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbern(phi[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
# y[i] ~ dbin(phi[i], n[i])
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
X[,"Loud"] = scale(X[,"Loud"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
# inits = function() {
#   inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
# }
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
# inits = function() {
#   inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
# }
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ ddexp(0.0, sqrt(2.0)) # has variance 1.0
}
} "
#dnorm(0.0, 1.0/4.0^2)
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
# inits = function() {
#   inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
# }
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
1.0/5.0^2
5.0^2
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^4)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^4)
}
} "
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct / dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
# inits = function() {
#   inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
# }
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
str(data_jags)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
# inits = function() {
#   inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
# }
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
# inits = function() {
#   inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
# }
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
inits = function() {
inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags,  init = inits, n.chains=3)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
inits = function() {
inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
}
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
update(mod, 1000) # burn-in
mod_sim = coda.samples(model=mod,
variable.names=params,
n.iter=5e3)
raftery.diag()
mod1_csim = as.mcmc(do.call(rbind, mod_sim))
## convergence diagnostics
plot(mod1_sim, ask=TRUE)
## convergence diagnostics
plot(mod_sim, ask=TRUE)
raftery.diag(mod_sim)
gelman.diag(mod_sim)
autocorr.diag(mod_sim)
autocorr.plot(mod_sim)
dev.off()
plot(mod_sim, ask=TRUE)
raftery.diag(mod_sim)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
#inits = function() {
#  inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
#}
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
update(mod, 1000) # burn-in
mod_sim = coda.samples(model=mod,
variable.names=params,
n.iter=5e3)
mod1_csim = as.mcmc(do.call(rbind, mod_sim))
## convergence diagnostics
plot(mod_sim, ask=TRUE)
raftery.diag(mod_sim)
data_jags$y = dat$Correct/dat$Trials # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
data_jags$y = dat$Correct  # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
update(mod, 1000) # burn-in
mod_sim = coda.samples(model=mod,
variable.names=params,
n.iter=5e3)
mod1_csim = as.mcmc(do.call(rbind, mod_sim))
gelman.diag(mod_sim)
raftery.diag(mod_sim)
head(X)
mod1_csim
# posterior estimates
apply(mod1_csim, 2, mean)
phi = (60*0.2369209) + (50*1.2153240)
phi
invlogit(phi)
exp(phi)/(1+exp(phi))
head(data_jags)
phi
exp(phi)
1+exp(phi)
exp(phi)/(1+exp(phi))
head(data_jags)
# Export configuration of covariates
X = model.matrix(mod_glm)[,-1] # -1 removes the column of 1s for the intercept
head(X)
# Jags time!
mod_string = " model {
for (i in 1:length(y)) {
y[i] ~ dbin(phi[i], n[i])
logit(phi[i]) = b0 + b[1]*Age[i] + b[2]*OMElow[i] + b[3]*Loud[i] + b[4]*Noiseincoherent[i]
}
b0 ~ dnorm(0.0, 1.0/5.0^2)
for (j in 1:4) {
b[j] ~ dnorm(0.0, 1.0/4.0^2)
}
} "
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
#X[,"Age"] = scale(X[,"Age"], center=TRUE, scale = TRUE)
data_jags = as.list(as.data.frame(X))
data_jags$y = dat$Correct  # this will not work if there are missing values in dat (because they would be ignored by model.matrix). Always make sure that the data are accurately pre-processed for JAGS.
data_jags$n = dat$Trials
str(data_jags) # make sure that all variables have the same number of observations (712).
params = c("b0", "b")
#inits = function() {
#  inits = list("b0"=rnorm(1,0.0,100.0), "b"=rnorm(4,0.0,100.0))
#}
mod = jags.model(textConnection(mod_string), data=data_jags,  n.chains=3)
update(mod, 1000) # burn-in
mod_sim = coda.samples(model=mod,
variable.names=params,
n.iter=5e3)
mod1_csim = as.mcmc(do.call(rbind, mod_sim))
## convergence diagnostics
plot(mod_sim, ask=TRUE)
raftery.diag(mod_sim)
apply(mod1_csim, 2, mean)
phi = (60*0.01890387) + (50*0.17197007)
exp(phi)/(1+exp(phi))
plot(as.factor(dat$Loud), dat$Correct / dat$Trials )
m_coef = apply(mod1_csim, 2, mean)
pm_Xb = pm_coef["b0"] + X %*% pm_coef[1:4]
phat = 1.0 / (1.0 + exp(-pm_Xb))
head(phat)
pm_coef = apply(mod1_csim, 2, mean)
pm_Xb = pm_coef["b0"] + X %*% pm_coef[1:4]
phat = 1.0 / (1.0 + exp(-pm_Xb))
head(phat)
(tab0.7 = table(phat > 0.7, (dat$Correct / dat$Trials) > 0.7))
sum(diag(tab0.7)) / sum(tab0.7)
